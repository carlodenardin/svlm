### Algorithm Overview

The algorithm is designed to perform a binary search on a sorted array of integers. The purpose of the algorithm is to find a specific integer value within the array by repeatedly dividing the search interval in half.

### Input Data

- **Array**: A sorted array of integers.
- **Target Value**: The integer value to be searched within the array.

### Main Logical Flow

1. **Initialize the Search Interval**:
   - Set the lower bound (`low`) to 0.
   - Set the upper bound (`high`) to the length of the array minus 1.

2. **While Loop**:
   - Continue the loop as long as the lower bound is less than or equal to the upper bound.

3. **Calculate Midpoint**:
   - Compute the midpoint index (`mid`) as `(low + high) // 2`.

4. **Compare Midpoint with Target**:
   - If the value at the midpoint index (`arr[mid]`) is equal to the target value, return the midpoint index.
   - If the value at the midpoint index is less than the target value, update the lower bound to `mid + 1`.
   - If the value at the midpoint index is greater than the target value, update the upper bound to `mid - 1`.

5. **Return -1**:
   - If the loop exits without finding the target value, return -1 to indicate that the target value is not in the array.

### Expected Output

- **Return the index** of the target value if found within the array.
- **Return -1** if the target value is not found within the array.

### Implementation Steps

1. **Initialize the Search Interval**:
   - Set `low = 0` and `high = len(array) - 1`.

2. **While Loop**:
   - While `low <= high`:
     - Compute `mid = (low + high) // 2`.
     - If `arr[mid] == target`:
       - Return `mid`.
     - If `arr[mid] < target`:
       - Update `low = mid + 1`.
     - If `arr[mid] > target`:
       - Update `high = mid - 1`.

3. **Return -1**:
   - If the loop exits